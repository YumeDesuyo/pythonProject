{"flag": true, "code": 20000, "message": "操作成功", "data": [{"id": 98, "articleCover": "http://blog-1314088710.cos.ap-shanghai.myqcloud.com/articles/b138812a00a152123e42f9ec2e77a66a.jpg", "articleTitle": "面经-1", "articleContent": "面经，直到我全部都答出来就取消设顶\n\n## 第一面\n\n一面主要考察的是一些基础的，面试时间大概30分钟\n\n- 自我介绍\n- 前端和后端项目你都做过，你未来的职业规划是什么?\n- 现在你投的是研发工程师，有初级、中级、高级，你觉得你是等级的？\n- 看你都是偏向于JavaWeb开发这块，有学习和了解过什么书籍来提升自己么？\n- 你觉得微服务架构能解决高并发问题呢？能解决哪一类？\n- 假设现在你是一个单体应用程序，然后能够支撑200的QPS，然后如果我想要能够支撑起400的QPS，那么你会怎么做？说说你的思路和解决方法\n\n\n\t1.水平扩展：水平扩展是指增加服务器的数量，将负载均衡到多个服务器上。通过水平扩展来增加QPS。这可以通过使用负载均衡器和集群来实现。将请求路由到不同的服务器，以平衡负载，提高应用程序的可伸缩性。\n\n\t2.垂直扩展：垂直扩展是指增加单个服务器的资源，例如增加CPU、内存、存储等。通过垂直扩展来提高单个服务器的性能。\n\n\t3.引入缓存层：将常用数据或计算结果缓存到内存或分布式缓存系统中，可以显著提高应用程序的响应时间和吞吐量。这样可以减轻数据库的压力，同时提高应用程序的可", "createTime": "2023-01-03T20:09:44", "isTop": 1, "type": 1, "categoryId": 200, "categoryName": "模拟面试", "tagDTOList": [{"id": 39, "tagName": "面试"}]}, {"id": 97, "articleCover": "http://blog-1314088710.cos.ap-shanghai.myqcloud.com/articles/2d59e192381fa39a3cdf2011fd5de3d8.jpg", "articleTitle": "面经-2", "articleContent": "\n  **一面（视频面）  1小时30分钟**  \n\n  - 类加载机制概念、加载步骤、双亲委托机制、全盘委托机制、类加载器种类及继承关系\n\t>类加载机制是指在Java虚拟机运行时将Java类的字节码从磁盘或网络加载到内存中并进行解析、验证、准备、初始化等一系列操作的过程。\n**Java类加载机制包括以下几个步骤：**\n加载：查找并加载类的字节码文件。\n验证：确保字节码文件符合Java虚拟机规范，并且没有安全问题。\n准备：为静态变量分配内存空间，并设置默认初始值。\n解析：将符号引用转换为直接引用。\n初始化：执行类的静态初始化代码块，包括赋初值和静态语句块。\nJava类加载器采用双亲委托机制，即每个类加载器在加载类时，先将请求委托给父加载器，如果父加载器无法加载，则由子加载器自己加载。这样可以保证类加载的层次结构，避免重复加载和类的版本冲突。\n双亲委托机制有两种具体实现方式：全盘委托机制和父亲委托机制。全盘委托机制要求在任何时候都只有一个类的定义，并且由高级别的类加载器来保证这一点。父亲委托机制则是在父加载器找不到类的情况下，才会由子加载器尝试加载。\nJava中常见的类加载器有以下四种：", "createTime": "2023-01-03T20:08:38", "isTop": 1, "type": 1, "categoryId": 200, "categoryName": "模拟面试", "tagDTOList": [{"id": 39, "tagName": "面试"}]}, {"id": 56, "articleCover": "http://blog-1314088710.cos.ap-shanghai.myqcloud.com/articles/cd2c126b5890c71a6044b733b2705ddc.jpg", "articleTitle": "小王子", "articleContent": "每个人心里都有一团火，路过的人只看到烟。但总有一个人，总有那么一个人能看到这团火，然后走过来，陪我一起。我带着我的热情，我的冷漠，我的狂暴，我的温和，以及对爱情毫无理由的相信，走的上气不接下气。我结结巴巴对她说：你叫什么名字。从你叫什么名字开始，后来，有了一切。", "createTime": "2022-10-11T14:49:01", "isTop": 1, "type": 1, "categoryId": 189, "categoryName": "文章分享", "tagDTOList": [{"id": 31, "tagName": "小王子"}]}, {"id": 115, "articleCover": "http://blog-1314088710.cos.ap-shanghai.myqcloud.com/articles/d1f3de3f88fb7a415f387f49f9dc03e1.png", "articleTitle": "面试准备", "articleContent": "**基础篇**\n2、面向对象和面向过程的区别\n\n3 、八种基本数据类型的大小，以及他们的封装类\nbyte short int long double float char boolean\nByte Short Integer Long Double Float Character Boolean\n\n4、标识符的命名规则。\n驼峰命名法\n\n5、instanceof 关键字的作用\ninstanceof 是 Java 的保留关键字。它的作用是测试它左边的对象是否是它右边的类的实例，返回 boolean 的数据类型。\n\n6、Java自动装箱与拆箱\n装箱就是自动将基本数据类型转换为封装类型，拆箱就是自动将封装类型转换为基本数据类型。以Integer为例，使用Integer.valueOf()方法实现装箱，使用Integer.intValue()方法实现拆箱。\n\n7、重载和重写的区别\n重载是同一个方法名可以使用多次，前提的参数的数量和类型不同，返回值类型和修饰符类型可以相同。重写是发生在子类与父类之间，子类重写父类的方法之后，子类重写的方法必须与父类的名字，参数类型，返回值类型完全相同。访问修饰符的", "createTime": "2023-03-21T13:05:28", "isTop": 0, "type": 1, "categoryId": 200, "categoryName": "模拟面试", "tagDTOList": [{"id": 39, "tagName": "面试"}]}, {"id": 114, "articleCover": "http://blog-1314088710.cos.ap-shanghai.myqcloud.com/articles/9f0126b907f6f7a92b32203184195737.jpg", "articleTitle": "JUC复习", "articleContent": "# JUC\n\n## 进程\n\n### 概述\n\n进程：程序是静止的，进程实体的运行过程就是进程，是系统进行**资源分配的基本单位**\n\n进程的特征：并发性、异步性、动态性、独立性、结构性\n\n**线程**：线程是属于进程的，是一个基本的 CPU 执行单元，是程序执行流的最小单元。线程是进程中的一个实体，是系统**独立调度的基本单位**，线程本身不拥有系统资源，只拥有一点在运行中必不可少的资源，与同属一个进程的其他线程共享进程所拥有的全部资源\n\n关系：一个进程可以包含多个线程，这就是多线程，比如看视频是进程，图画、声音、广告等就是多个线程\n\n线程的作用：使多道程序更好的并发执行，提高资源利用率和系统吞吐量，增强操作系统的并发性能\n\n并发并行：\n\n* 并行：在同一时刻，有多个指令在多个 CPU 上同时执行\n* 并发：在同一时刻，有多个指令在单个 CPU 上交替执行\n\n同步异步：\n\n* 需要等待结果返回，才能继续运行就是同步\n* 不需要等待结果返回，就能继续运行就是异步\n\n\n\n\n\n\n\n***\n\n\n\n### 对比\n\n线程进程对比：\n\n* 进程基本上相互独立的，而线程存在于进程内，是进程的一个子集\n\n", "createTime": "2023-01-12T15:47:45", "isTop": 0, "type": 1, "categoryId": 192, "categoryName": "JUC", "tagDTOList": [{"id": 34, "tagName": "JUC"}]}, {"id": 113, "articleCover": "http://blog-1314088710.cos.ap-shanghai.myqcloud.com/articles/620483281909addf94e615bf603f8659.jpg", "articleTitle": "JVM复习-11", "articleContent": "\n\n\n\n垃圾回收器\n============\n\nGC 分类与性能指标\n------------\n\n### 垃圾回收器概述\n\n\n\n1.  垃圾收集器没有在规范中进行过多的规定，可以由不同的厂商、不同版本的JVM来实现。\n\n2.  由于JDK的版本处于高速迭代过程中，因此Java发展至今已经衍生了众多的GC版本。\n\n3.  从不同角度分析垃圾收集器，可以将GC分为不同的类型。\n\n\n\n\n**Java不同版本新特性**\n\n1.  语法层面：Lambda表达式、switch、自动拆箱装箱、enum、泛型\n2.  API层面：Stream API、新的日期时间、Optional、String、集合框架\n3.  底层优化：JVM优化、GC的变化、元空间、静态域、字符串常量池等\n\n### 垃圾回收器分类\n\n**按线程数分（垃圾回收线程数），可以分为串行垃圾回收器和并行垃圾回收器。**\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_012/0001.png\">\n\n1.  串行回收指的是在同一时间段内只允许有一个CPU用于执行", "createTime": "2023-01-11T16:27:44", "isTop": 0, "type": 1, "categoryId": 190, "categoryName": "JVM", "tagDTOList": [{"id": 32, "tagName": "JVM"}]}, {"id": 112, "articleCover": "http://blog-1314088710.cos.ap-shanghai.myqcloud.com/articles/b71aaf9db7303f33285a409e04bfeea2.jpg", "articleTitle": "JVM复习-10", "articleContent": "\n\n\n\n垃圾回收相关概念\n===============\n\nSystem.gc() 的理解\n-----------------\n\n\n\n1.  在默认情况下，通过System.gc()者Runtime.getRuntime().gc() 的调用，**会显式触发Full GC**，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。\n\n2.  然而System.gc()调用附带一个免责声明，无法保证对垃圾收集器的调用(不能确保立即生效)\n\n3.  JVM实现者可以通过System.gc() 调用来决定JVM的GC行为。而一般情况下，垃圾回收应该是自动进行的，**无须手动触发，否则就太过于麻烦了。**在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用System.gc()\n\n\n\n\n**代码示例：手动执行 GC 操作**\n\n```java\npublic class SystemGCTest {\n    public static void main(String[] args) {\n        new SystemGCTest();\n        System.", "createTime": "2023-01-11T16:26:37", "isTop": 0, "type": 1, "categoryId": 190, "categoryName": "JVM", "tagDTOList": [{"id": 32, "tagName": "JVM"}]}, {"id": 111, "articleCover": "http://blog-1314088710.cos.ap-shanghai.myqcloud.com/articles/0af09b63670250b6ceb6ea90879ddf3e.jpg", "articleTitle": "JVM复习-9", "articleContent": "\n\n垃圾回收概述\n=============\n\n\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_010/0001.png\">\n\n1.  Java 和 C++语言的区别，就在于垃圾收集技术和内存动态分配上，C++语言没有垃圾收集技术，需要程序员手动的收集。\n\n2.  垃圾收集，不是Java语言的伴生产物。早在1960年，第一门开始使用内存动态分配和垃圾收集技术的Lisp语言诞生。\n\n3.  关于垃圾收集有三个经典问题：\n\n    *   哪些内存需要回收？\n    *   什么时候回收？\n    *   如何回收？\n4.  垃圾收集机制是Java的招牌能力，极大地提高了开发效率。如今，垃圾收集几乎成为现代语言的标配，即使经过如此长时间的发展，Java的垃圾收集机制仍然在不断的演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战，这当然也是面试的热点。\n\n\n\n\n## 大厂面试题\n\n### 蚂蚁金服\n\n1.  你知道哪几种垃圾回收器，各自的优缺点，重点讲一下CMS和G1？\n2.  JVM GC算法", "createTime": "2023-01-11T16:25:52", "isTop": 0, "type": 1, "categoryId": 190, "categoryName": "JVM", "tagDTOList": [{"id": 32, "tagName": "JVM"}]}, {"id": 110, "articleCover": "http://blog-1314088710.cos.ap-shanghai.myqcloud.com/articles/4877c55affb0d92d6808dd8531f43278.jpg", "articleTitle": "JVM复习-8", "articleContent": "StringTable（字符串常量池）\n==================\n\nString的基本特性\n--------------\n\n\n\n1.  String：字符串，使用一对 “” 引起来表示\n\n  ```java\n    String s1 = \"atguigu\" ;   \t\t\t// 字面量的定义方式\n    String s2 =  new String(\"hello\");     // new 对象的方式\n  ```\n\n2.  String被声明为final的，不可被继承\n\n3.  String实现了Serializable接口：表示字符串是支持序列化的。实现了Comparable接口：表示String可以比较大小\n\n4.  String在jdk8及以前内部定义了`final char value[]`用于存储字符串数据。JDK9时改为`byte[]`\n\n\n## 为什么 JDK9 改变了 String 的结构\n\n>  **官方文档**：http://openjdk.java.net/jeps/254\n\n\n\n**为什么改为 byte\\[\\] 存储？**\n\n1.  String类", "createTime": "2023-01-11T16:25:00", "isTop": 0, "type": 1, "categoryId": 190, "categoryName": "JVM", "tagDTOList": [{"id": 32, "tagName": "JVM"}]}, {"id": 109, "articleCover": "http://blog-1314088710.cos.ap-shanghai.myqcloud.com/articles/9820284db7bc8823af5df4b54b11a1fa.jpg", "articleTitle": "JVM复习-7", "articleContent": "执行引擎\n===========\n\n执行引擎概述\n--------\n\n\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_008/0001.png\">\n\n### 执行引擎概述\n\n\n\n1.  执行引擎是Java虚拟机核心的组成部分之一。\n2.  “虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而**虚拟机的执行引擎则是由软件自行实现的**，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，**能够执行那些不被硬件直接支持的指令集格式**。\n3.  JVM的主要任务是负责**装载字节码到其内部**，但字节码并不能够直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被JVM所识别的字节码指令、符号表，以及其他辅助信息。\n4.  那么，如果想要让一个Java程序运行起来，执行引擎（Execution Engine）的任务就是**将字节码指令解释/编译为对应平台上的本地机器指令才", "createTime": "2023-01-11T16:24:15", "isTop": 0, "type": 1, "categoryId": 190, "categoryName": "JVM", "tagDTOList": [{"id": 32, "tagName": "JVM"}]}]}